#! env python3

from __future__ import annotations

from typing import List, Dict
import abc

import boto3
import secrets
import sys
import os
import stat
import time
import subprocess
import tempfile

import resource
import blob

ec2 = boto3.resource('ec2', 'us-east-1')

class KeyPair(resource.Resource):
    """Resource representing an RSA key pair generated by EC2 and used to access instances"""
    def __init__(self, name:str=None):
        self.name = name
        self.private = None
    
    def plan(self):
        if self.private is None:
            self.private = blob.File(f"{self.name}.pvt", "pem")
        self.private.plan()

    def up(self, top):
        if self.private.is_loaded():
            print(f"{self.__class__.__qualname__}({self.name}).plan : reusing private key")
        else:
            print(f"{self.__class__.__qualname__}({self.name}).plan : creating a new key")
            key_pair = ec2.create_key_pair(KeyName=self.name)
            self.private.load(key_pair.key_material)
            self.private.write()
            os.chmod(self.private.filename(), 0o600)
            top.save()

    def down(self, top):
        if self.private.is_loaded():
            print(f"{self.__class__.__qualname__}({self.name}).down : deleting key pair on EC2")
            keypair = ec2.KeyPair(self.name)
            keypair.delete()
            self.private.clear()
            self.private.delete()
            top.save()

    def marshal(self, visitor):
        visitor.beginObject(self)
        visitor.inline('name')
        visitor.inline('private')
        visitor.endObject(self)

class SecurityGroup(resource.Resource):
    """Resource representing TCP/IP inbound/outbound port security rules applied to a group of instances"""
    def __init__(self, name: str=None, description: str=None):
        self.name = name
        self.description = description
        self.ec2_security_group_id = None
    
    def plan(self):
        pass

    def up(self, top):
        if self.ec2_security_group_id is not None:
            print(f"{self.__class__.__qualname__}({self.name}).up : EC2 security group is already allocated")
        else:
            print(f"{self.__class__.__qualname__}({self.name}).plan : creating a new security group")
            ec2_security_group = ec2.create_security_group(GroupName=self.name, Description=self.description)
            self.ec2_security_group_id = ec2_security_group.id
            ip_permissions = [{
                'IpProtocol': 'tcp', 'FromPort': 3001, 'ToPort': 3001,
                'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
            }]
            ip_permissions.append({
                # SSH ingress open to only the specified IP address
                'IpProtocol': 'tcp', 'FromPort': 22, 'ToPort': 22,
                'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
            })
            ec2_security_group.authorize_ingress(IpPermissions=ip_permissions)
            top.save()

    def down(self, top):
        if self.ec2_security_group_id is not None:
            print(f"{self.__class__.__qualname__}({self.name}).down : deleting security group on EC2")
            security_group = ec2.SecurityGroup(self.ec2_security_group_id)
            security_group.delete()
            self.ec2_security_group_id = None
            top.save()

    def marshal(self, visitor):
        visitor.beginObject(self)
        visitor.inline('name')
        visitor.inline('description')
        visitor.inline('ec2_security_group_id')
        visitor.endObject(self)

class PublicIp(resource.Resource):
    """Resource representing an allocated public IP address that can be associated with an instance"""
    def __init__(self, name: str=None):
        self.name = name
        self.ec2_allocation_id = None
        self.ip_address = None

    def plan(self):
        pass

    def up(self, top):
        if self.ec2_allocation_id is not None:
            print(f"{self.__class__.__qualname__}({self.name}).up : EC2 public IP is already allocated")
        else:
            print(f"{self.__class__.__qualname__}({self.name}).up : creating a new public IP")
            response = ec2.meta.client.allocate_address()
            self.ec2_allocation_id = response['AllocationId']
            self.ip_address = response['PublicIp']
            top.save()

    def down(self, top):
        if self.ec2_allocation_id is not None:
            print(f"{self.__class__.__qualname__}({self.name}).down : releasing EC2 public IP")
            ec2.meta.client.release_address(AllocationId=self.ec2_allocation_id)
            self.ec2_allocation_id = None
        self.ip_address = None
        top.save()

    def marshal(self, visitor):
        visitor.beginObject(self)
        visitor.inline('name')
        visitor.inline('ec2_allocation_id')
        visitor.inline('ip_address')
        visitor.endObject(self)

class Service(resource.Resource):
    """Resource representing a Systemd service definition which calls commands we provide"""
    def __init__(self, name: str=None, description: str=None, instance: Instance=None, commands: List[str]=None):
        self.name = name
        self.description = description
        self.instance = instance
        self.commands = commands
        self.is_loaded = False

    def plan(self):
        pass

    def up(self, top):
        if self.is_loaded:
            print(f"{self.__class__.__qualname__}({self.name}).up : service is already defined on instance {self.instance.name}")
        else:
            print(f"{self.__class__.__qualname__}({self.name}).up : registering service on instance {self.instance.name}")
            service_config = f"""
[Unit]
Description={self.description}

[Service]	
ExecStart=/usr/bin/bash -c /home/ec2-user/{self.name}.sh

[Install]
WantedBy=default.target"""
            service_config_file = blob.File(self.name+'-service', 'cfg')
            service_config_file.load(service_config.strip())
            system_path = f"/etc/systemd/system/{self.name}.service"
            self.instance.put(service_config_file, system_path, 60, sudo=True, chmod='0664')

            entry_script = '\n'.join([ '#env bash' ] + self.commands)
            entry_script_file = blob.File(self.name, 'sh')
            entry_script_file.load(entry_script.strip())
            self.instance.put(entry_script_file, f"/home/ec2-user/{self.name}.sh", 60, chmod='0775')

            self.instance.execute(['sudo', 'systemctl', 'daemon-reload'], 60)
            self.instance.execute(['sudo', 'systemctl', 'start', f"{self.name}.service"], 60)
            self.is_loaded = True
            top.save()

    def down(self, top):
        if self.is_loaded:
            print(f"{self.__class__.__qualname__}({self.name}).up : un-registering service on instance {self.instance.name}")
            self.instance.execute(['sudo', 'systemctl', 'stop', f"{self.name}.service"], 60)
            self.instance.execute(['sudo', 'rm', '-f', f"/etc/systemd/system/{self.name}.service"], 60)
            self.instance.execute(['sudo', 'systemctl', 'daemon-reload'], 60)
            self.is_loaded = False
            top.save()

    def watch(self):
        self.instance.execute(['sudo', 'journalctl', '-f', '-u', self.name], timeout=None)

    def ip(self):
        print(self.instance.public_ip.ip_address)

    def ssh(self):
        self.instance.shell()

    def stop(self):
        if self.is_loaded:
            self.instance.execute(['sudo', 'systemctl', 'stop', f"{self.name}.service"], 60)

    def start(self):
        if self.is_loaded:
            self.instance.execute(['sudo', 'systemctl', 'start', f"{self.name}.service"], 60)

    def get(self, remote_path:str, local_path: str):
        self.instance.get(remote_path, local_path)

    def put(self, local_path:str, remote_path: str):
        self.instance.put(local_path, remote_path)

    def marshal(self, visitor):
        visitor.beginObject(self)
        visitor.inline('name')
        visitor.inline('description')
        visitor.inline('instance')
        visitor.inline('commands')
        visitor.inline('is_loaded')
        visitor.endObject(self)

    
class Instance(resource.Resource):
    """Resource representing a virtual host in the on-demand AWS EC2 cloud"""
    def __init__(self, name: str=None, instance_type: str=None, image: str=None, key_pair: KeyPair=None, security_group: SecurityGroup=None, public_ip: PublicIp=None):
        self.name = name
        self.ec2_instance_id = None
        self.instance_type = instance_type
        self.image = image
        self.key_pair = key_pair
        self.security_group = security_group
        self.public_ip = public_ip
        self.puts = dict() # id(local_object) => { local_timestamp, remote_path }

    def plan(self):
        pass

    def wait_for_status(self, expected):
        tries = 0
        while tries < 10:
            instance = ec2.Instance(self.ec2_instance_id)
            status = instance.state['Name']
            if status == expected:
                break
            print(f'Waiting 5 more seconds for {self.name} with EC2 Instance ID {self.ec2_instance_id} has status {status}')
            time.sleep(10)
            tries += 1

        if tries == 10:
            raise RuntimeError(f'Instance did not reach a running state in {tries} attempts')

    def up(self, top):
        if self.ec2_instance_id is not None:
            print(f"{self.__class__.__qualname__}({self.name}).up : EC2 instance id is already loaded")
        else:
            print(f"{self.__class__.__qualname__}({self.name}).up : creating EC2 instance in security group {self.security_group.name}")
            ec2_instances = ec2.create_instances(ImageId=self.image, InstanceType=self.instance_type, KeyName=self.key_pair.name, SubnetId='subnet-00b393af9a75c85a2', MinCount=1, MaxCount=1, SecurityGroupIds=[self.security_group.ec2_security_group_id])
            time.sleep(1)
            ec2_instances[0].create_tags(Tags=[{ 'Key': 'Name', 'Value': self.name }])
            self.ec2_instance_id = ec2_instances[0].id
            time.sleep(10)
            top.save()

        # wait for the instance to reach running state
        self.wait_for_status('running')

        # associate the public IP
        elastic_ip = ec2.VpcAddress(self.public_ip.ec2_allocation_id)
        elastic_ip.associate(InstanceId=self.ec2_instance_id)

        # wait for the instance to accept SSH connections and commands
        tries = 0
        while tries < 10:
            try:
                self.test()
                break
            except Exception as e:
                print(str(e))
                print(f'Waiting 5 more seconds for {self.name} with EC2 Instance ID {self.ec2_instance_id} to accept SSH connections and commands')
                time.sleep(10)
                tries += 1

        if tries == 10:
            raise RuntimeError(f'Instance did not accept SSH connections and commands after {tries} attempts')

    def down(self, top):
        if self.ec2_instance_id is not None:
            print(f"{self.__class__.__qualname__}({self.name}).down : deleting EC2 instance")
            instance = ec2.Instance(self.ec2_instance_id)
            instance.terminate()

            # wait for the instance to reach running state
            self.wait_for_status('terminated')
            self.ec2_instance_id = None
            top.save()

    def test(self):
        with tempfile.NamedTemporaryFile('wt+', delete=False) as keyfile:
            args=['echo', 'hello world']
            timeout=2
            keyfile.write(self.key_pair.private.contents)
            keyfile.close()
            os.chmod(keyfile.name, stat.S_IREAD | stat.S_IWRITE)
            time.sleep(1)
            process = subprocess.Popen(['ssh', '-A', '-o', 'StrictHostKeyChecking=no', '-o', 'ForwardAgent=yes', '-i', keyfile.name, 'ec2-user@' + self.public_ip.ip_address ] + args, stdin=None, stdout=sys.stdout, stderr=sys.stderr)
            process.communicate(timeout=timeout)
            if process.returncode != 0:
                raise RuntimeError(f'Cannot connect over SSH to {self.name} rc={process.returncode}')

    def shell(self):
        with tempfile.NamedTemporaryFile('wt+', delete=False) as keyfile:
            keyfile.write(self.key_pair.private.contents)
            keyfile.close()
            os.chmod(keyfile.name, stat.S_IREAD | stat.S_IWRITE)
            time.sleep(1)
            remote_args = ['ssh', '-A', '-o', 'StrictHostKeyChecking=no', '-o', 'ForwardAgent=yes', '-i', keyfile.name, 'ec2-user@' + self.public_ip.ip_address ]
            print(f"EXEC({self.name}) "+' '.join(remote_args))
            process = subprocess.Popen(remote_args, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
            while process.returncode is None:
                try:
                    process.communicate(timeout=1)
                except subprocess.TimeoutExpired:
                    pass
            os.unlink(keyfile.name)
            if process.returncode != 0:
                raise RuntimeError(f'EXEC FAILED with rc={process.returncode}')

    def execute(self, args: List[str], timeout: float, stdin=None, cwd=None):
        with tempfile.NamedTemporaryFile('wt+', delete=False) as keyfile:
            keyfile.write(self.key_pair.private.contents)
            keyfile.close()
            os.chmod(keyfile.name, stat.S_IREAD | stat.S_IWRITE)
            time.sleep(1)
            chdir_args = [ 'cd', cwd, '&&' ] if cwd is not None else []
            remote_args = ['ssh', '-A', '-T', '-o', 'StrictHostKeyChecking=no', '-o', 'ForwardAgent=yes', '-i', keyfile.name, 'ec2-user@' + self.public_ip.ip_address ] + chdir_args + args
            print(f"EXEC({self.name}) "+' '.join(remote_args))
            process = subprocess.Popen(remote_args, stdin=stdin, stdout=sys.stdout, stderr=sys.stderr, shell=False)
            if timeout is None:
                while process.returncode is None:
                    try:
                        process.communicate(timeout=1)
                    except subprocess.TimeoutExpired:
                        pass
            else:
                process.communicate(timeout=timeout)
            os.unlink(keyfile.name)
            if process.returncode != 0:
                raise RuntimeError(f'EXEC FAILED with rc={process.returncode}')

    def get(self, remote_path: str, local_path: str, timeout: int):
        with tempfile.NamedTemporaryFile('wt+', delete=False) as keyfile:
            keyfile.write(self.key_pair.private.contents)
            keyfile.close()
            os.chmod(keyfile.name, stat.S_IREAD | stat.S_IWRITE)
            time.sleep(1)
            args = [ 'ec2-user@' + self.public_ip.ip_address + ':' + remote_path, local_path ]
            process = subprocess.Popen(['scp', '-o', 'StrictHostKeyChecking=no', '-o', 'ForwardAgent=yes', '-i', keyfile.name ] + args, stdin=None, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            (stdout, stderr) = process.communicate(timeout=timeout)
            print(stdout.decode('utf-8') + stderr.decode('utf-8'))
            os.unlink(keyfile.name)

    def put(self, local: str|blob.File, remote_path: str, timeout:int, sudo=False, chmod:str=None):
        with tempfile.NamedTemporaryFile('wt+', delete=False) as keyfile:
            keyfile.write(self.key_pair.private.contents)
            keyfile.close()
            os.chmod(keyfile.name, stat.S_IREAD | stat.S_IWRITE)
            time.sleep(1)
            if isinstance(local, str):
                use = local
            else:
                local.write()
                use = local.filename()
            if sudo:
                tmp_path = secrets.token_urlsafe(10)
                args = [ use, 'ec2-user@' + self.public_ip.ip_address + ':' + tmp_path ]
            else:
                tmp_path = None
                args = [ use, 'ec2-user@' + self.public_ip.ip_address + ':' + remote_path ]

            process = subprocess.Popen(['scp', '-o', 'StrictHostKeyChecking=no', '-o', 'ForwardAgent=yes', '-i', keyfile.name ] + args, stdin=None, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            (stdout, stderr) = process.communicate(timeout=timeout)
            print(stdout.decode('utf-8') + stderr.decode('utf-8'))

            if sudo:
                self.execute(['sudo', 'mv', '-f', tmp_path, remote_path ], 60)

            os.unlink(keyfile.name)
            if chmod is not None:
                self.execute((['sudo'] if sudo else []) + ['chmod', chmod, remote_path ], 60)

    def marshal(self, visitor):
        visitor.beginObject(self)
        visitor.inline('name')
        visitor.inline('ec2_instance_id')
        visitor.inline('instance_type')
        visitor.inline('image')
        visitor.inline('key_pair')
        visitor.inline('security_group')
        visitor.inline('public_ip')
        visitor.endObject(self)

class Cluster(resource.Resource):
    """Resource representing a virtual cluster in the on-demand AWS EC2 cloud"""
    def __init__(self, name: str=None, instance_type: str=None, image: str=None, key_pair: KeyPair=None, security_group=None, public_ip: PublicIp=None, count: int = 1):
        self.name = name
        self.instance_type = instance_type
        self.image = image
        self.key_pair = key_pair
        self.security_group = security_group
        self.public_ip = public_ip
        self.count = count
        self.instances = None

    def plan(self):
        if self.instances is None:
            self.instances = []
            for i in range(self.count):
                instance = Instance(f"{self.name}#{i}", self.instance_type, self.image, self.key_pair, self.security_group, self.public_ip)
                self.instances.append(instance)
        for instance in self.instances:
            instance.plan()

    def order_of_operations(self):
        return self.instances

    def marshal(self, visitor):
        visitor.beginObject(self)
        visitor.inline('name')
        visitor.inline('instance_type')
        visitor.inline('image')
        visitor.inline('key_pair')
        visitor.inline('security_group')
        visitor.inline('public_ip')
        visitor.inline('count')
        visitor.inline('instances')
        visitor.endObject(self)

